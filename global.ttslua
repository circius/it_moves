-- http://steamcommunity.com/sharedfiles/filedetails/?id=924691456
function onload()
    GM_NOTES_NAME_FOR_THING_CARD = "THE THING"
    GM_NOTES_NAME_FOR_SUCCESS = "S"
    GM_NOTES_NAME_FOR_FAILURE = "F"
    GAME_STATES = {
        "Briefing", "Assignments", "Work", "Debrief", "Isolation",
        "Assimilation"
    }
    CURRENT_GAME_STATE = 0
    BLINDNESS = false
    MIN_PLAYERS = 6
    MAX_PLAYERS = 9
    ACTUAL_PLAYERS = nil
    --[[ print('Onload!') --]]
end

--[[ getters ]]
get_game_state = function()
    -- consumes nothing and produces the name of the current game state.
    return GAME_STATES[CURRENT_GAME_STATE + 1]
end
--[[ setters ]]
advance_game_state = function()
    --- consumes nothing and advances the current game state
    CURRENT_GAME_STATE = (CURRENT_GAME_STATE + 1) % #GAME_STATES
    return get_game_state()
end

reverse_game_state = function()
    --- consumes nothing and reverses the current game state
    candidate = CURRENT_GAME_STATE - 1
    if candidate < 0 then
        CURRENT_GAME_STATE = #GAME_STATES - 1
    else
        CURRENT_GAME_STATE = candidate
    end
    return get_game_state()
end
--[[ predicates ]]
function is_missioncard_p(any)
    -- consumes whatever object description and returns 'true' if it's a missioncard,
    -- false otherwise.
    -- return true
    -- match = string.find(any.getName(), "::difficulty")
    local name_or_nil = any.getName()
    return string.find(name_or_nil, "diff") ~= nil
end
--[[ functions to assist working with "types"]]
function get_quasi_type(obj)
    -- consumes an object and gets a TTS quasi-type
    return obj_parse_to_string(tostring(obj))[1]
end

function obj_parse_to_string(obj)
    -- consumes an object and produces a table representing the parsed
    -- components of its tostring output

    elements = string.gmatch(str, "[%a_]+")
    result_table = {}
    i = 1
    for element in elements do
        result_table[i] = element
        i = i + 1
    end
    return result_table
end
--[[ card-counting functions ]]
function count_successes(deckOrCard)
    -- consumes an object and produces and produces
    -- the number of cards in the suits of hearts and
    -- diamonds it contains.
    item_class = get_quasi_type(deckOrCard)
    if item_class == "Card" then
        return card_count_successes(deckOrCard)
    elseif item_class == "Deck" then
        return deck_count_successes(deckOrCard)
    else
        return -1
    end
end

function count_jokers(deckOrCard)
    -- consumes an object and produces the number of
    -- jokers it contains. Returns -1 if the items could
    -- not be, or contain, a Joker.
    item_class = get_quasi_type(deckOrCard)
    if item_class == "Card" then
        return card_count_jokers(deckOrCard)
    elseif item_class == "Deck" then
        return deck_count_jokers(deckOrCard)
    else
        return -1
    end
end

function card_count_jokers(card)
    -- consumes a card and produces 1 if it's a joker, 0
    -- otherwise
    if is_a_joker(card) then
        return 1
    else
        return 0
    end
end
function is_a_joker(obj)
    -- consumes an object and produces 'true' if the card's a joker,
    -- false otherwise
    return obj.getGMNotes() == GM_NOTES_NAME_FOR_THING_CARD
end

function card_desc_is_a_joker(card_desc)
    -- consumes a card-description (result of deck.getObjects)
    -- and produces 'true' if the description is of a joker,
    -- 'false' otherwise
    return card_desc.gm_notes == GM_NOTES_NAME_FOR_THING_CARD
end

function deck_count_jokers(deck)
    -- consumes a deck and produces the number of jokers it contains
    cards = deck.getObjects()
    local count = 0
    for _, card_desc in pairs(cards) do
        if card_desc_is_a_joker(card_desc) then count = count + 1 end
    end
    return count
end

function card_is_success(card)
    -- consumes a card and produces 'true' if it's
    -- a success, 'false' otherwise
    return card.getGMNotes() == GM_NOTES_NAME_FOR_SUCCESS
end

function card_count_successes(card)
    -- consumes a card and produces 1 if that card is a success,
    -- 0 otherwise
    if card_is_success(card) then
        return 1
    else
        return 0
    end
end

function card_desc_is_success(card_desc)
    -- consumes a card_description and produces
    -- true if it represents a success card, false otherwise.
    return card_desc.gm_notes == GM_NOTES_NAME_FOR_SUCCESS
end

function deck_count_successes(deck)
    -- consumes a deck and produces the number of successes in it.
    cards = deck.getObjects()
    local count = 0
    for _, card_desc in pairs(cards) do
        if card_desc_is_success(card_desc) then count = count + 1 end
    end
    return count
end
--[[ functions helping to manage collision-based objects ]]
function should_ignore_collision_p(collision_info)
    if collision_info.collision_object == nil or collision_info.collision_object ==
        self or collision_info.collision_object.getGUID() == nil or
        collision_info.collision_object.tag == "Surface" or
        collision_info.collision_object.tag == "Board" or objectLoaded then
        return true
    else
        return false
    end
end
--[[ The OnLoad function. This is called after everything in the game save finishes loading.
    Most of your script code goes here. --]]
--[[ Lua code. See documentation: http://berserk-games.com/knowledgebase/scripting/ --]]
--[[ The Update function. This is called once per frame. --]]
function update() --[[ print('Update loop!') --]]end
